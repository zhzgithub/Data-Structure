
【1】程序设计 = 数据结构 + 算法 

【2】顺序存储结构--------------如：数组结构
	顺序存储结构是把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。
	
【3】链式存储结构--------------如：医院按号看病，不需要排队。
	在计算机中用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的).
	它不要求逻辑上相邻的元素在物理位置上也相邻.因此它没有顺序存储结构所具有的弱点,但也同时失去了顺序表可随机存取的优点.
	用一个指针存放数据元素的地址，这样子通过地址就可以找到相关元素的位置。
	
【4】算法有5个基本特征：输入，输出，有穷性，确定性，可行性。
	【4_1】输入:算法可以有0个或多个输入。比如打印函数打印"I am ET"就不需要输入了。
	【4_2】输出：算法至少有1个或多个输出
	【4_3】有穷性：算法最终会自动结束而不会出现无限循环。一个永远都不会结束的算法是没有意义的。
	【4_4】确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。
		           算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果
				   算法的每个步骤都应该被精确定义而无歧义。
	【4_5】可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。
	
【5】算法初体验--------求从1加到100
	执行一次到底是执行一句算一次，还是执行一行啥的，咋这么模糊？
	方法一：需要运行100次		//这种算法执行了1+(n+1)+n=2n+2次
		int i,sum=0,n=100;		//执行了1次
		for(i=1,i<=n,i++)		//执行了n+1次,+1是因为执行判断语句i<=n
		{
			sum=sum+i;			//执行了n次
		}
		printf("%d",sum)
		
	方法二：-----高斯算法---		//这种算法执行了1+1=2次
		int i,sum=0,n=100;			//执行了1次
		sum=(1+n)*n/2				//执行了1次
		printf("%d",sum)
		
【6】算法的 时间复杂度 和 空间复杂度
	【6_1】时间复杂度：T(n)=O(f(n))
		语句的总执行次数T(n)是关于问题规模n的函数。T(n)=O(f(n))表示岁问题规模n的增大，算法执行时间
		的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数
		用大写O()来体现算法时间复杂度的记法，称之为大O记法。
		一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。
		O(1)<O(n)<O(n^2)
		【6_1_1】	如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？
			--用常数1取代运行时间中的所有加法常数
			--在修改后的运行次数函数中，只保留最高阶项
			--如果最高项存在且不是1，则去除与这个项相乘的常数（即去掉系数），如3*n^2 时O(n^2)
		【6_1_2】对数阶
			int i=1,n=100;
			while(i<n)
			{
				i=i*2
			}
			由于每次i*2 之后，就距离n更近一步。假设有x个2相乘后>=n,则会退出循环。即2^x=n。x为循环的次数，
			x=log(2)n,所以这个循环的复杂度为O(logn)。
			log(2)n的时间复杂度是O(logn)，可以去掉2。log(2)n和log(10)n的时间复杂度都是O(logn)
			
			之前的时间复杂度跟指数型扯不上关系的，是线型阶，所以用不到对数阶。也就是步长为2，与步长乘以2的区别。
			比如T(n)=2*n次，而对数阶是2^x=n，T(n)=logn。
		【6_1_3】常数阶O(1)，      线型阶O(n)，    平方阶O(n^2)，       对数阶O(logn)，
				 nlogn阶O(nlogn)：3nlog(2)n+2n。   立方阶：O(n^3)，     指数阶O(2^n)
			常用的时间复杂度所耗费的时间从小到大依次是：O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
		【6_1_4】我们查找有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度就是O(1)，
			最坏的情况是这个数字在最后一个位置，那么时间的复杂度为O(n)。
			平均运行时间是期望的运行时间。
			最坏的运行时间是一种保证。在应用中，这是一种最重要的需求。通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
		
	【6_2】空间复杂度
		一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的
		内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，
		还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。
		程序执行时所需存储空间包括以下两部分：　　
		（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数
			据空间（常量、简单变量）等所占的空间。这部分属于静态空间。
		（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。
			一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。

	【6_3】空间上的开销来换取计算时间开销。到底哪一种方法好，要看用在什么地方。
	比如1. 用某个算法（比如能否整除4）求闰年，每次输入一个年份就用这个算法来计算一下得到结果。这种方法节省空间
		2. 把年份是闰年的记为1，不是的年份记为0，内存中存储这个数组。每次查询只需要一次索引判断即可。这种方法耗费内存空间































