
【1】程序设计 = 数据结构 + 算法 

【2】顺序存储结构--------------如：数组结构
	顺序存储结构是把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。
	
【3】链式存储结构--------------如：医院按号看病，不需要排队。
	在计算机中用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的,也可以是不连续的).
	它不要求逻辑上相邻的元素在物理位置上也相邻.因此它没有顺序存储结构所具有的弱点,但也同时失去了顺序表可随机存取的优点.
	用一个指针存放数据元素的地址，这样子通过地址就可以找到相关元素的位置。
------------------------------------------------------------------------------------------------------
	
【4】算法有5个基本特征：输入，输出，有穷性，确定性，可行性。
	【4_1】输入:算法可以有0个或多个输入。比如打印函数打印"I am ET"就不需要输入了。
	【4_2】输出：算法至少有1个或多个输出
	【4_3】有穷性：算法最终会自动结束而不会出现无限循环。一个永远都不会结束的算法是没有意义的。
	【4_4】确定性：算法的每一个步骤都具有确定的含义，不会出现二义性。
		           算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果
				   算法的每个步骤都应该被精确定义而无歧义。
	【4_5】可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

	
【5】算法初体验--------求从1加到100
	执行一次到底是执行一句算一次，还是执行一行啥的，咋这么模糊？
	方法一：需要运行100次		//这种算法执行了1+(n+1)+n=2n+2次
		int i,sum=0,n=100;		//执行了1次
		for(i=1,i<=n,i++)		//执行了n+1次,+1是因为执行判断语句i<=n
		{
			sum=sum+i;			//执行了n次
		}
		printf("%d",sum)
		
	方法二：-----高斯算法---		//这种算法执行了1+1=2次
		int i,sum=0,n=100;			//执行了1次
		sum=(1+n)*n/2				//执行了1次
		printf("%d",sum)
		
【6】算法的 时间复杂度 和 空间复杂度
	【61】时间复杂度：T(n)=O(f(n))
		语句的总执行次数T(n)是关于问题规模n的函数。T(n)=O(f(n))表示岁问题规模n的增大，算法执行时间
		的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数
		用大写O()来体现算法时间复杂度的记法，称之为大O记法。
		一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。
		O(1)<O(n)<O(n^2)
		【611】	如何分析一个算法的时间复杂度呢？即如何推导大O阶呢？
			--用常数1取代运行时间中的所有加法常数
			--在修改后的运行次数函数中，只保留最高阶项
			--如果最高项存在且不是1，则去除与这个项相乘的常数（即去掉系数），如3*n^2 时O(n^2)
		【612】对数阶
			int i=1,n=100;
			while(i<n)
			{
				i=i*2
			}
			由于每次i*2 之后，就距离n更近一步。假设有x个2相乘后>=n,则会退出循环。即2^x=n。x为循环的次数，
			x=log(2)n,所以这个循环的复杂度为O(logn)。
			log(2)n的时间复杂度是O(logn)，可以去掉2。log(2)n和log(10)n的时间复杂度都是O(logn)
			
			之前的时间复杂度跟指数型扯不上关系的，是线型阶，所以用不到对数阶。也就是步长为2，与步长乘以2的区别。
			比如T(n)=2*n次，而对数阶是2^x=n，T(n)=logn。
		【613】常数阶O(1)，      线型阶O(n)，    平方阶O(n^2)，       对数阶O(logn)，
				 nlogn阶O(nlogn)：3nlog(2)n+2n。   立方阶：O(n^3)，     指数阶O(2^n)
			常用的时间复杂度所耗费的时间从小到大依次是：O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
		【614】我们查找有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度就是O(1)，
			最坏的情况是这个数字在最后一个位置，那么时间的复杂度为O(n)。
			平均运行时间是期望的运行时间。
			最坏的运行时间是一种保证。在应用中，这是一种最重要的需求。通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。
		
	【62】空间复杂度
		一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的
		内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，
		还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。
		程序执行时所需存储空间包括以下两部分：　　
		（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数
			据空间（常量、简单变量）等所占的空间。这部分属于静态空间。
		（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。
			一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。

	【63】空间上的开销来换取计算时间开销。到底哪一种方法好，要看用在什么地方。
		比如-- 用某个算法（比如能否整除4）求闰年，每次输入一个年份就用这个算法来计算一下得到结果。这种方法节省空间
			-- 把年份是闰年的记为1，不是的年份记为0，内存中存储这个数组。每次查询只需要一次索引判断即可。这种方法耗费内存空间
-------------------------------------------------------------------------------------------------------------------------------

【7】线性表
	【71】线性表：由0个或多个数据元素组成的有限序列。-------------排队时记住自己前面的人即可
		  线性表元素的个数n(>=0)定义为线性表的长度，当n=0 时，称为空表。
		
	这里需要强调几个关键的地方：
	--首先他是一个序列，也就是说元素之间是有个先来后到。
	--若元素存在多个，则第一个元素无前驱，而最后一个元素无后继；其他元素都有且只有一个前驱和后继。
	--另外，线性表强调是有限的，事实上无论计算机发展到多强大，他所处理的元素都是有限的。

	【72】数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。
		  例如编程语言的整型，浮点型，字符型这些指的就是数据类型。
	
		例如在C语言中，按照取值的不同，数据类型可以分为两类：
		  --原子类型：不可以再分解的基本类型，例如整型，浮点型，字符型等；
		  --结构类型：由若干个类型组合而成，是可以再分解的，例如整型数组是由若干整型数据组成的。
	  
	【73】抽象：是指抽取出事物具有的普遍性的本质。
		  抽象数据类型：对已有的数据类型进行抽象，就有了抽象数据类型。抽象数据类型是指一个数学模型及定义在该模型上的一组操作。
		  抽象数据类型的定义仅取决于他的一组逻辑特性，而与其在计算及内部如何表示和实现无关。
		  比如1+1=2 这样一个操作，在不同的cpu的处理上可能不一样，但由于其定义的数学特性相同，所以在计算机编程者看来，他们都是相同的。
	【74】operation
		InitList(*L):初始化操作，建立一个空的线性表L。
		ListEmpty(L):判断线性表是否为空表，若为空表返回True,否则返回False
		ClearList(*L):将线性表清空
		GetElem(L,i,*e):将线性表L中的第i个位置元素值返回给e
		LocateElem(L,e):在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败
		ListInsert(*L,i,e):在线性表L中第i个位置插入新元素e
		ListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用返回其值e
		ListLength(L):返回线性表L的元素个数
	
	
	






























